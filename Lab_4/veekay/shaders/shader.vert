#version 450

// ============================================================================
// ВХОДНЫЕ ДАННЫЕ (АТРИБУТЫ ВЕРШИН)
// ============================================================================
// Данные поступают из vertex buffer для каждой вершины модели
layout(location = 0) in vec3 in_position;  // Позиция вершины в локальных координатах модели
layout(location = 1) in vec3 in_normal;    // Нормаль вершины (для расчета освещения)
layout(location = 2) in vec2 in_uv;        // Текстурные координаты (не используются в этой лабе)

// ============================================================================
// СТРУКТУРЫ ДАННЫХ
// ============================================================================
// Должны совпадать с определениями в C++ и фрагментном шейдере!

// Направленный свет (глобальное освещение)
struct DirectionalLight {
    vec3 direction;   // Направление света
    float _pad0;      // Выравнивание для std140
    vec3 ambient;     // Фоновая составляющая
    float _pad1;
    vec3 diffuse;     // Диффузная составляющая
    float _pad2;
    vec3 specular;    // Зеркальная составляющая
    float _pad3;
};

// ============================================================================
// UNIFORM-БУФЕРЫ (ДАННЫЕ СЦЕНЫ И МОДЕЛИ)
// ============================================================================

// Глобальные данные сцены (одинаковые для всех вершин всех объектов)
layout(binding = 0) uniform SceneUniforms {
    mat4 view_projection;                  // Комбинированная матрица вид-проекция (камера)
    vec3 view_position;                    // Позиция камеры в мировых координатах
    float _pad0;
    DirectionalLight directional_light;    // Параметры глобального направленного света
    uint point_light_count;                // Количество точечных источников
    uint spot_light_count;                 // Количество прожекторов
    float _pad1;
    float _pad2;
    mat4 light_space_matrix;               // Матрица для shadow mapping
} scene;

// Данные текущей модели (индивидуальные для каждого объекта)
layout(binding = 1) uniform ModelUniforms {
    mat4 model;              // Матрица трансформации модели (Model matrix)
    vec3 albedo_color;       // Основной цвет материала (диффузный компонент)
    float shininess;         // Степень блеска поверхности
    vec3 specular_color;     // Цвет зеркального отражения
    float _pad0;
} model;

// ============================================================================
// ВЫХОДНЫЕ ДАННЫЕ (ПЕРЕДАЮТСЯ В ФРАГМЕНТНЫЙ ШЕЙДЕР)
// ============================================================================
// Эти значения будут интерполированы для каждого пикселя треугольника
layout(location = 0) out vec3 frag_position;  // Позиция вершины в мировых координатах
layout(location = 1) out vec3 frag_normal;    // Нормаль в мировых координатах
layout(location = 2) out vec2 frag_uv;        // Текстурные координаты (для будущего использования)
layout(location = 3) out vec4 frag_position_light_space;  // Позиция в пространстве света

// ============================================================================
// ГЛАВНАЯ ФУНКЦИЯ ВЕРШИННОГО ШЕЙДЕРА
// ============================================================================
// Выполняется для каждой вершины модели
// Задачи:
// 1. Трансформировать вершину в экранные координаты (clip space)
// 2. Подготовить данные для фрагментного шейдера (позиция, нормаль)
void main() {
    // ========================================================================
    // ТРАНСФОРМАЦИЯ ПОЗИЦИИ
    // ========================================================================
    
    // Шаг 1: Преобразуем вершину из локальных координат модели в мировые координаты
    // Применяем матрицу модели (учитываем масштаб, поворот, сдвиг объекта)
    vec4 world_position = model.model * vec4(in_position, 1.0);
    
    // Шаг 2: Преобразуем мировые координаты в clip space (финальные экранные координаты)
    // Применяем матрицу вид-проекция (учитываем положение камеры и перспективу)
    gl_Position = scene.view_projection * world_position;
    
    // ========================================================================
    // ПОДГОТОВКА ДАННЫХ ДЛЯ ФРАГМЕНТНОГО ШЕЙДЕРА
    // ========================================================================
    
    // Передаем позицию вершины в мировых координатах
    // (нужна для расчета направления к источникам света и камере)
    frag_position = world_position.xyz;
    
    // Трансформируем нормаль в мировое пространство
    // Используем только вращательную часть матрицы модели (mat3)
    // Это корректно работает при равномерном масштабировании
    // Примечание: для неравномерного масштаба нужна inverse-transpose матрица
    frag_normal = mat3(model.model) * in_normal;
    
    // Передаем текстурные координаты без изменений
    frag_uv = in_uv;
    
    // НОВОЕ: Вычисляем позицию в light space для shadow mapping
    frag_position_light_space = scene.light_space_matrix * world_position;
}